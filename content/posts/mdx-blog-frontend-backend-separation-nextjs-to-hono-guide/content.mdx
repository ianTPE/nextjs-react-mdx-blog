export const metadata = {
  title: 'MDX éƒ¨è½æ ¼å¦‚ä½•å¯¦ç¾å‰å¾Œç«¯åˆ†é›¢ï¼Ÿå¾ Next.js å–®é«”åˆ° Hono API çš„å®Œæ•´å‡ç´šè·¯å¾‘',
  date: '2025-06-03',
  author: 'Ian Chou',
  excerpt: 'æ·±å…¥æ¢è¨ MDX éƒ¨è½æ ¼æ¶æ§‹æ¼”é€²ï¼Œå¾ Next.js å–®é«”æ‡‰ç”¨åˆ°çœŸæ­£çš„å‰å¾Œç«¯åˆ†é›¢ã€‚æä¾›ä¸‰éšæ®µæ¼¸é€²å¼å‡ç´šæ–¹æ¡ˆï¼šæ–‡ä»¶ç³»çµ± â†’ API Routes â†’ Hono APIï¼ŒåŒ…å«å®Œæ•´å¯¦ç¾ä»£ç¢¼ã€æ€§èƒ½å°æ¯”å’Œé·ç§»æ­¥é©Ÿã€‚',
  tags: ['Next.js', 'MDX', 'Hono', 'å‰å¾Œç«¯åˆ†é›¢', 'API Routes', 'æ¶æ§‹è¨­è¨ˆ', 'Performance'],
  coverImage: '/images/posts/mdx-blog-separation.webp',
  readingTime: 25,
  featured: true,
  category: 'Architecture'
};

# MDX éƒ¨è½æ ¼å‰å¾Œç«¯åˆ†é›¢é€²åŒ–æŒ‡å—ï¼šå¾å–®é«”æ‡‰ç”¨åˆ°å¾®æœå‹™æ¶æ§‹

éš¨è‘— MDX éƒ¨è½æ ¼è¦æ¨¡çš„å¢é•·ï¼Œè¨±å¤šé–‹ç™¼è€…é–‹å§‹æ€è€ƒä¸€å€‹å•é¡Œï¼š**å¦‚ä½•å¯¦ç¾å‰å¾Œç«¯åˆ†é›¢ï¼Ÿ** æ˜¯ä¸€æ¬¡æ€§é‡æ§‹æ•´å€‹æ¶æ§‹ï¼Œé‚„æ˜¯æ¡ç”¨æ¼¸é€²å¼çš„å‡ç´šç­–ç•¥ï¼Ÿ

åœ¨é€™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘å°‡å¸¶ä½ èµ°éä¸€å€‹å®Œæ•´çš„æ¶æ§‹æ¼”é€²ä¹‹è·¯ï¼Œå¾æœ€ç°¡å–®çš„å–®é«”æ‡‰ç”¨é–‹å§‹ï¼Œé€æ­¥å‡ç´šåˆ°çœŸæ­£çš„å‰å¾Œç«¯åˆ†é›¢æ¶æ§‹ã€‚æ¯å€‹éšæ®µéƒ½æœ‰å…¶é©ç”¨å ´æ™¯ï¼Œä½ å¯ä»¥æ ¹æ“šé …ç›®éœ€æ±‚æ±ºå®šåœåœ¨å“ªå€‹éšæ®µï¼Œæˆ–è€…ç¹¼çºŒå‘ä¸‹ä¸€éšæ®µæ¼”é€²ã€‚

<EvolutionOverview />

è®“æˆ‘å€‘æ·±å…¥æ¯å€‹éšæ®µï¼Œäº†è§£å¯¦ç¾æ–¹æ³•ã€é©ç”¨å ´æ™¯ä»¥åŠå‡ç´šæ™‚æ©Ÿã€‚

<Stage1Architecture />

### ğŸ›  å…¸å‹å¯¦ç¾

```typescript
// lib/mdx.ts - æ–‡ä»¶ç³»çµ±æ“ä½œ
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const postsDirectory = path.join(process.cwd(), 'content/posts');

export function getAllPostSlugs() {
  return fs.readdirSync(postsDirectory);
}

export function getPostBySlug(slug: string) {
  const fullPath = path.join(postsDirectory, slug, 'content.mdx');
  const fileContents = fs.readFileSync(fullPath, 'utf8');
  const { data, content } = matter(fileContents);
  
  return {
    slug,
    metadata: data,
    content,
  };
}

export function getAllPosts() {
  const slugs = getAllPostSlugs();
  return slugs
    .map(slug => getPostBySlug(slug))
    .sort((a, b) => new Date(b.metadata.date).getTime() - new Date(a.metadata.date).getTime());
}
```

```typescript
// app/blog/[slug]/page.tsx
import { MDXRemote } from 'next-mdx-remote/rsc';
import { getPostBySlug, getAllPostSlugs } from '@/lib/mdx';

export async function generateStaticParams() {
  const slugs = getAllPostSlugs();
  return slugs.map(slug => ({ slug }));
}

export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = getPostBySlug(params.slug);
  
  return (
    <article>
      <h1>{post.metadata.title}</h1>
      <MDXRemote source={post.content} />
    </article>
  );
}
```

### âœ… å„ªå‹¢
- **é–‹ç™¼é€Ÿåº¦å¿«**ï¼šç„¡éœ€è¨­è¨ˆ APIï¼Œç›´æ¥è®€å–æ–‡ä»¶
- **éƒ¨ç½²ç°¡å–®**ï¼šä¸€å€‹æœå‹™æå®šæ‰€æœ‰åŠŸèƒ½
- **SEO å‹å¥½**ï¼šå®Œå…¨éœæ…‹ç”Ÿæˆ
- **æˆæœ¬ä½**ï¼šå–®ä¸€éƒ¨ç½²ï¼Œé‹ç¶­ç°¡å–®

### âŒ ç¼ºé»
- **æ§‹å»ºæ™‚é–“éš¨æ–‡ç« æ•¸é‡å¢é•·**ï¼šæ¯ç¯‡æ–‡ç« éƒ½éœ€è¦åœ¨æ§‹å»ºæ™‚è™•ç†
- **éƒ¨ç½²åŒ…é«”ç©å¤§**ï¼šæ‰€æœ‰æ–‡ç« éƒ½æ‰“åŒ…åˆ°éƒ¨ç½²ä¸­
- **ç„¡æ³•å‹•æ…‹æ›´æ–°**ï¼šä¿®æ”¹æ–‡ç« éœ€è¦é‡æ–°éƒ¨ç½²
- **æ²’æœ‰çœŸæ­£çš„ API**ï¼šç„¡æ³•çµ¦å…¶ä»–å®¢æˆ¶ç«¯ä½¿ç”¨

### ğŸš¨ å‡ç´šè§¸ç™¼é»
- æ§‹å»ºæ™‚é–“è¶…é 5 åˆ†é˜
- æ–‡ç« æ•¸é‡è¶…é 1,000 ç¯‡
- éœ€è¦å‹•æ…‹æ›´æ–°å…§å®¹
- å¸Œæœ›æä¾› API çµ¦å…¶ä»–æ‡‰ç”¨ä½¿ç”¨

---

## éšæ®µ 2ï¼šNext.js + API Routesï¼ˆå½å‰å¾Œç«¯åˆ†é›¢ï¼‰

<Stage2Architecture />

### ğŸ“‹ æ¶æ§‹æ¼”é€²

å°‡æ–‡ç« å…§å®¹å¾æ–‡ä»¶ç³»çµ±é·ç§»åˆ°æ•¸æ“šåº«ï¼Œä½¿ç”¨ Next.js çš„ API Routes æä¾› API ç«¯é»ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Next.js æ‡‰ç”¨ç¨‹å¼             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  å‰ç«¯éƒ¨åˆ†ï¼š                          â”‚
â”‚  â”œâ”€â”€ app/blog/[slug]/page.tsx      â”‚
â”‚  â”œâ”€â”€ app/blog/page.tsx             â”‚
â”‚  â””â”€â”€ components/MDXRenderer.tsx    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  API éƒ¨åˆ†ï¼š                          â”‚
â”‚  â”œâ”€â”€ app/api/articles/route.ts     â”‚
â”‚  â”œâ”€â”€ app/api/articles/[slug]/route.ts â”‚
â”‚  â””â”€â”€ app/api/revalidate/route.ts   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“ API èª¿ç”¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       PostgreSQL/PlanetScale       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ articles è¡¨                     â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ id (ä¸»éµ)                   â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ slug (å”¯ä¸€)                 â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ title                      â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ content (MDX æ–‡æœ¬)          â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ metadata (JSON)            â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ created_at                 â”‚â”‚
â”‚  â”‚ â””â”€â”€ updated_at                 â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ—„ æ•¸æ“šåº«è¨­è¨ˆ

```sql
-- æ–‡ç« è¡¨
CREATE TABLE articles (
  id VARCHAR(255) PRIMARY KEY,
  slug VARCHAR(255) UNIQUE NOT NULL,
  title TEXT NOT NULL,
  content TEXT NOT NULL, -- MDX å…§å®¹
  metadata JSON NOT NULL, -- åŒ…å« author, tags, publishedAt ç­‰
  view_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- ç´¢å¼•å„ªåŒ–
CREATE INDEX idx_articles_slug ON articles(slug);
CREATE INDEX idx_articles_created_at ON articles(created_at DESC);
CREATE INDEX idx_articles_metadata_tags ON articles((CAST(metadata->'$.tags' AS JSON ARRAY)));

-- å…¨æ–‡æœç´¢ï¼ˆMySQLï¼‰
ALTER TABLE articles ADD FULLTEXT(title, content);

-- æ¨™ç±¤è¡¨ï¼ˆå¯é¸ï¼Œç”¨æ–¼æ¨™ç±¤ç®¡ç†ï¼‰
CREATE TABLE tags (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(100) UNIQUE NOT NULL,
  slug VARCHAR(100) UNIQUE NOT NULL,
  article_count INT DEFAULT 0
);
```

### ğŸ”§ API Routes å¯¦ç¾

```typescript
// app/api/articles/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const limit = parseInt(searchParams.get('limit') || '10');
  const tag = searchParams.get('tag');
  const search = searchParams.get('search');
  
  try {
    const where: any = {};
    
    if (tag) {
      where.metadata = {
        path: ['tags'],
        array_contains: tag
      };
    }
    
    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { content: { contains: search, mode: 'insensitive' } }
      ];
    }

    const [articles, total] = await Promise.all([
      prisma.article.findMany({
        where,
        select: {
          id: true,
          slug: true,
          title: true,
          metadata: true,
          view_count: true,
          created_at: true,
          updated_at: true
        },
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { created_at: 'desc' }
      }),
      prisma.article.count({ where })
    ]);

    return NextResponse.json({
      articles,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch articles' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { title, content, metadata, slug } = body;
    
    // ç°¡å–®çš„èªè­‰ï¼ˆç”Ÿç”¢ç’°å¢ƒéœ€è¦æ›´å¼·çš„èªè­‰ï¼‰
    const authHeader = request.headers.get('authorization');
    if (!authHeader || authHeader !== `Bearer ${process.env.API_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const article = await prisma.article.create({
      data: {
        id: crypto.randomUUID(),
        slug,
        title,
        content,
        metadata,
      }
    });

    return NextResponse.json({ article }, { status: 201 });
  } catch (error) {
    console.error('Create article error:', error);
    return NextResponse.json(
      { error: 'Failed to create article' },
      { status: 500 }
    );
  }
}
```

```typescript
// app/api/articles/[slug]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const article = await prisma.article.findUnique({
      where: { slug: params.slug }
    });

    if (!article) {
      return NextResponse.json(
        { error: 'Article not found' },
        { status: 404 }
      );
    }

    // å¢åŠ ç€è¦½æ¬¡æ•¸
    await prisma.article.update({
      where: { slug: params.slug },
      data: { view_count: { increment: 1 } }
    });

    return NextResponse.json({ article });
  } catch (error) {
    console.error('Get article error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch article' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const body = await request.json();
    const authHeader = request.headers.get('authorization');
    
    if (!authHeader || authHeader !== `Bearer ${process.env.API_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const article = await prisma.article.update({
      where: { slug: params.slug },
      data: {
        ...body,
        updated_at: new Date()
      }
    });

    return NextResponse.json({ article });
  } catch (error) {
    console.error('Update article error:', error);
    return NextResponse.json(
      { error: 'Failed to update article' },
      { status: 500 }
    );
  }
}
```

### ğŸ”„ å‰ç«¯èª¿ç”¨å°è£

```typescript
// lib/api.ts
interface Article {
  id: string;
  slug: string;
  title: string;
  content?: string; // åˆ—è¡¨é ä¸åŒ…å«å®Œæ•´å…§å®¹
  metadata: {
    author: string;
    publishedAt: string;
    tags: string[];
    excerpt: string;
    readingTime: number;
  };
  view_count: number;
  created_at: string;
  updated_at: string;
}

class BlogAPI {
  private baseURL = '/api'; // åŒåŸŸèª¿ç”¨ï¼Œç„¡éœ€ CORS

  async getArticles(params?: {
    page?: number;
    limit?: number;
    tag?: string;
    search?: string;
  }) {
    const searchParams = new URLSearchParams();
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          searchParams.append(key, value.toString());
        }
      });
    }

    const response = await fetch(`${this.baseURL}/articles?${searchParams}`, {
      next: { revalidate: 300 } // 5 åˆ†é˜ç·©å­˜
    });
    
    if (!response.ok) {
      throw new Error(`Failed to fetch articles: ${response.status}`);
    }
    
    return response.json() as Promise<{
      articles: Article[];
      pagination: {
        page: number;
        limit: number;
        total: number;
        pages: number;
      };
    }>;
  }

  async getArticle(slug: string) {
    const response = await fetch(`${this.baseURL}/articles/${slug}`, {
      next: { revalidate: 3600 } // 1 å°æ™‚ç·©å­˜
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error('Article not found');
      }
      throw new Error(`Failed to fetch article: ${response.status}`);
    }
    
    return response.json() as Promise<{ article: Article }>;
  }

  async createArticle(data: {
    title: string;
    slug: string;
    content: string;
    metadata: Article['metadata'];
  }) {
    const response = await fetch(`${this.baseURL}/articles`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.NEXT_PUBLIC_API_SECRET}`
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error('Failed to create article');
    }

    return response.json();
  }
}

export const blogAPI = new BlogAPI();
```

### ğŸ“± å‰ç«¯é é¢æ›´æ–°

```typescript
// app/blog/[slug]/page.tsx
import { Metadata } from 'next';
import { notFound } from 'next/navigation';
import { MDXRemote } from 'next-mdx-remote/rsc';
import { blogAPI } from '@/lib/api';
import { mdxComponents } from '@/components/mdx';

interface PageProps {
  params: { slug: string };
}

export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
  try {
    const { article } = await blogAPI.getArticle(params.slug);
    
    return {
      title: article.title,
      description: article.metadata.excerpt,
      openGraph: {
        title: article.title,
        description: article.metadata.excerpt,
        type: 'article',
        publishedTime: article.metadata.publishedAt,
        authors: [article.metadata.author],
        tags: article.metadata.tags
      }
    };
  } catch (error) {
    return { title: 'Article Not Found' };
  }
}

export default async function BlogPost({ params }: PageProps) {
  try {
    const { article } = await blogAPI.getArticle(params.slug);
    
    return (
      <article className="max-w-4xl mx-auto px-4 py-8">
        <header className="mb-8">
          <h1 className="text-4xl font-bold mb-4">{article.title}</h1>
          <div className="flex items-center text-gray-600 mb-4">
            <span>By {article.metadata.author}</span>
            <span className="mx-2">â€¢</span>
            <time dateTime={article.metadata.publishedAt}>
              {new Date(article.metadata.publishedAt).toLocaleDateString()}
            </time>
            <span className="mx-2">â€¢</span>
            <span>{article.metadata.readingTime} min read</span>
            <span className="mx-2">â€¢</span>
            <span>{article.view_count} views</span>
          </div>
          <div className="flex flex-wrap gap-2">
            {article.metadata.tags.map((tag) => (
              <span 
                key={tag} 
                className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm"
              >
                {tag}
              </span>
            ))}
          </div>
        </header>
        
        <div className="prose prose-lg max-w-none">
          <MDXRemote source={article.content!} components={mdxComponents} />
        </div>
      </article>
    );
  } catch (error) {
    notFound();
  }
}

// ä¸å†éœ€è¦ generateStaticParamsï¼Œæ”¹ç”¨ ISR
export const revalidate = 3600; // 1 å°æ™‚
```

```typescript
// app/blog/page.tsx
import Link from 'next/link';
import { blogAPI } from '@/lib/api';

interface PageProps {
  searchParams: {
    page?: string;
    tag?: string;
    search?: string;
  };
}

export default async function BlogList({ searchParams }: PageProps) {
  const page = parseInt(searchParams.page || '1');
  const { articles, pagination } = await blogAPI.getArticles({
    page,
    limit: 10,
    tag: searchParams.tag,
    search: searchParams.search
  });

  return (
    <div className="max-w-4xl mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Blog Posts</h1>
      
      <div className="space-y-8">
        {articles.map((article) => (
          <article key={article.id} className="border-b pb-6">
            <h2 className="text-2xl font-semibold mb-2">
              <Link 
                href={`/blog/${article.slug}`}
                className="hover:text-blue-600 transition-colors"
              >
                {article.title}
              </Link>
            </h2>
            
            <div className="text-gray-600 text-sm mb-3">
              <span>{article.metadata.author}</span>
              <span className="mx-2">â€¢</span>
              <time dateTime={article.metadata.publishedAt}>
                {new Date(article.metadata.publishedAt).toLocaleDateString()}
              </time>
              <span className="mx-2">â€¢</span>
              <span>{article.view_count} views</span>
            </div>
            
            <p className="text-gray-700 mb-4">{article.metadata.excerpt}</p>
            
            <div className="flex flex-wrap gap-2">
              {article.metadata.tags.map((tag) => (
                <Link
                  key={tag}
                  href={`/blog?tag=${tag}`}
                  className="px-2 py-1 bg-gray-100 text-gray-700 rounded text-sm hover:bg-gray-200"
                >
                  {tag}
                </Link>
              ))}
            </div>
          </article>
        ))}
      </div>
      
      {/* åˆ†é  */}
      <div className="flex justify-center mt-12">
        <div className="flex gap-2">
          {Array.from({ length: pagination.pages }, (_, i) => i + 1).map((pageNum) => (
            <Link
              key={pageNum}
              href={`/blog?page=${pageNum}`}
              className={`px-3 py-1 rounded ${
                pageNum === pagination.page
                  ? 'bg-blue-500 text-white'
                  : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
              }`}
            >
              {pageNum}
            </Link>
          ))}
        </div>
      </div>
    </div>
  );
}

export const revalidate = 300; // 5 åˆ†é˜
```

### ğŸ”„ ISR é‡æ–°é©—è­‰

```typescript
// app/api/revalidate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { revalidatePath } from 'next/cache';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { slug, secret } = body;
    
    if (secret !== process.env.REVALIDATE_SECRET) {
      return NextResponse.json({ error: 'Invalid secret' }, { status: 401 });
    }

    // é‡æ–°é©—è­‰ç‰¹å®šé é¢
    if (slug) {
      revalidatePath(`/blog/${slug}`);
    }
    
    // é‡æ–°é©—è­‰åˆ—è¡¨é 
    revalidatePath('/blog');
    
    return NextResponse.json({ 
      revalidated: true, 
      timestamp: Date.now() 
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Error revalidating' }, 
      { status: 500 }
    );
  }
}
```

### ğŸ“Š é·ç§»è…³æœ¬

```typescript
// scripts/migrate-to-database.ts
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function migratePostsToDatabase() {
  const postsDirectory = path.join(process.cwd(), 'content/posts');
  const slugs = fs.readdirSync(postsDirectory);
  
  console.log(`Found ${slugs.length} posts to migrate`);
  
  for (const slug of slugs) {
    try {
      const fullPath = path.join(postsDirectory, slug, 'content.mdx');
      const fileContents = fs.readFileSync(fullPath, 'utf8');
      const { data, content } = matter(fileContents);
      
      // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
      const existing = await prisma.article.findUnique({
        where: { slug }
      });
      
      if (existing) {
        console.log(`Skipping ${slug} - already exists`);
        continue;
      }
      
      await prisma.article.create({
        data: {
          id: crypto.randomUUID(),
          slug,
          title: data.title,
          content,
          metadata: {
            author: data.author,
            publishedAt: data.date,
            tags: data.tags || [],
            excerpt: data.excerpt,
            readingTime: data.readingTime || 5
          }
        }
      });
      
      console.log(`âœ… Migrated: ${slug}`);
    } catch (error) {
      console.error(`âŒ Failed to migrate ${slug}:`, error);
    }
  }
  
  await prisma.$disconnect();
  console.log('Migration completed!');
}

migratePostsToDatabase().catch(console.error);
```

### âœ… éšæ®µ 2 å„ªå‹¢
- **æ€§èƒ½å¤§å¹…æå‡**ï¼šæ§‹å»ºæ™‚é–“ä¸å†å—æ–‡ç« æ•¸é‡å½±éŸ¿
- **å‹•æ…‹æ›´æ–°**ï¼šå¯ä»¥é€šé API æ›´æ–°å…§å®¹ï¼Œé…åˆ ISR å³æ™‚ç”Ÿæ•ˆ
- **éƒ¨ç½²åŒ…å°**ï¼šåªåŒ…å«æ‡‰ç”¨ä»£ç¢¼ï¼Œä¸åŒ…å«æ–‡ç« å…§å®¹
- **å…·å‚™ API**ï¼šç‚ºæœªä¾†å¤šå®¢æˆ¶ç«¯æ”¯æ´åšæº–å‚™
- **ä¿æŒç°¡å–®**ï¼šä»ç„¶æ˜¯å–®ä¸€æœå‹™éƒ¨ç½²

### âŒ éšæ®µ 2 ç¼ºé»
- **å½åˆ†é›¢**ï¼šå‰å¾Œç«¯ä»åœ¨åŒä¸€å€‹é …ç›®ä¸­
- **æ“´å±•æ€§å—é™**ï¼šAPI Routes æ€§èƒ½ä¸å¦‚å°ˆæ¥­å¾Œç«¯æ¡†æ¶
- **å–®é»æ•…éšœ**ï¼šå‰ç«¯å’Œ API å…±äº«åŒä¸€å€‹éƒ¨ç½²
- **åœ˜éšŠå”ä½œ**ï¼šå‰å¾Œç«¯ç„¡æ³•å®Œå…¨ç¨ç«‹é–‹ç™¼

### ğŸš¨ å‡ç´šè§¸ç™¼é»
- éœ€è¦å¤šå€‹å®¢æˆ¶ç«¯ï¼ˆWeb + ç§»å‹•æ‡‰ç”¨ï¼‰
- å‰å¾Œç«¯åœ˜éšŠå¸Œæœ›ç¨ç«‹é–‹ç™¼éƒ¨ç½²
- API æ€§èƒ½æˆç‚ºç“¶é ¸
- éœ€è¦æ›´éˆæ´»çš„éƒ¨ç½²ç­–ç•¥

---

## éšæ®µ 3ï¼šNext.js å‰ç«¯ + ç¨ç«‹ API å±¤ï¼ˆçœŸæ­£åˆ†é›¢ï¼‰

<Stage3Architecture />

### ğŸ“‹ çµ‚æ¥µæ¶æ§‹

å®Œå…¨åˆ†é›¢çš„å‰å¾Œç«¯æ¶æ§‹ï¼Œæ¯å€‹æœå‹™éƒ½å¯ä»¥ç¨ç«‹é–‹ç™¼ã€éƒ¨ç½²å’Œæ“´å±•ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Next.js å‰ç«¯           â”‚    â”‚       Hono API æœå‹™         â”‚
â”‚                             â”‚    â”‚                             â”‚
â”‚  â”œâ”€â”€ app/blog/[slug]/      â”‚    â”‚  â”œâ”€â”€ routes/articles.ts     â”‚
â”‚  â”œâ”€â”€ app/blog/page.tsx     â”‚â—„â”€â”€â–ºâ”‚  â”œâ”€â”€ routes/auth.ts         â”‚
â”‚  â”œâ”€â”€ components/           â”‚    â”‚  â”œâ”€â”€ routes/search.ts       â”‚
â”‚  â””â”€â”€ lib/api.ts            â”‚    â”‚  â””â”€â”€ middleware/            â”‚
â”‚                             â”‚    â”‚      â”œâ”€â”€ auth.ts           â”‚
â”‚  éƒ¨ç½²ï¼šVercel               â”‚    â”‚      â”œâ”€â”€ cache.ts          â”‚
â”‚  åŸŸåï¼šblog.com             â”‚    â”‚      â””â”€â”€ cors.ts           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                             â”‚
                                   â”‚  éƒ¨ç½²ï¼šCloudflare Workers   â”‚
                                   â”‚  åŸŸåï¼šapi.blog.com         â”‚
                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                   â”‚      æ•¸æ“šå­˜å„²å±¤             â”‚
                                   â”‚                             â”‚
                                   â”‚  â”œâ”€â”€ PostgreSQL (ä¸»æ•¸æ“šåº«)  â”‚
                                   â”‚  â”œâ”€â”€ Redis (ç·©å­˜)          â”‚
                                   â”‚  â”œâ”€â”€ Cloudflare R2 (æ–‡ä»¶)  â”‚
                                   â”‚  â””â”€â”€ Elasticsearch (æœç´¢)  â”‚
                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”¥ Hono API æœå‹™å¯¦ç¾

```typescript
// api/src/index.ts
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { articlesRouter } from './routes/articles';
import { authRouter } from './routes/auth';
import { searchRouter } from './routes/search';
import { uploadRouter } from './routes/upload';

const app = new Hono();

// å…¨å±€ä¸­é–“ä»¶
app.use('*', logger());
app.use('/api/*', cors({
  origin: ['https://blog.com', 'http://localhost:3000'],
  credentials: true,
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
}));

// è·¯ç”±
app.route('/api/articles', articlesRouter);
app.route('/api/auth', authRouter);
app.route('/api/search', searchRouter);
app.route('/api/upload', uploadRouter);

// å¥åº·æª¢æŸ¥
app.get('/health', (c) => c.json({ 
  status: 'ok', 
  timestamp: Date.now(),
  version: '1.0.0',
  environment: c.env.ENVIRONMENT || 'development'
}));

// å…¨å±€éŒ¯èª¤è™•ç†
app.onError((err, c) => {
  console.error('Global error:', err);
  return c.json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  }, 500);
});

export default app;
```

**é«˜æ€§èƒ½æ–‡ç«  APIï¼š**
```typescript
// api/src/routes/articles.ts
import { Hono } from 'hono';
import { z } from 'zod';
import { authMiddleware } from '../middleware/auth';
import { cacheMiddleware } from '../middleware/cache';

const articlesRouter = new Hono();

// é¡å‹é©—è­‰
const ArticleSchema = z.object({
  title: z.string().min(1).max(200),
  slug: z.string().regex(/^[a-z0-9-]+$/),
  content: z.string().min(1),
  metadata: z.object({
    author: z.string(),
    publishedAt: z.string().datetime(),
    tags: z.array(z.string()),
    excerpt: z.string().max(500),
    readingTime: z.number().positive()
  })
});

// ç²å–æ–‡ç« åˆ—è¡¨ - å¸¶ç·©å­˜
articlesRouter.get('/', cacheMiddleware(300), async (c) => {
  const page = parseInt(c.req.query('page') || '1');
  const limit = Math.min(parseInt(c.req.query('limit') || '10'), 50);
  const tag = c.req.query('tag');
  const author = c.req.query('author');
  const sort = c.req.query('sort') || 'publishedAt';
  
  try {
    let query = `
      SELECT id, slug, title, metadata, view_count, created_at, updated_at
      FROM articles 
      WHERE 1=1
    `;
    const params: any[] = [];
    
    if (tag) {
      query += ` AND JSON_EXTRACT(metadata, '$.tags') LIKE ?`;
      params.push(`%"${tag}"%`);
    }
    
    if (author) {
      query += ` AND JSON_EXTRACT(metadata, '$.author') = ?`;
      params.push(author);
    }
    
    query += ` ORDER BY ${sort} DESC LIMIT ? OFFSET ?`;
    params.push(limit, (page - 1) * limit);
    
    const articles = await c.env.DB.prepare(query).bind(...params).all();
    
    // ç²å–ç¸½æ•¸
    let countQuery = `SELECT COUNT(*) as total FROM articles WHERE 1=1`;
    const countParams: any[] = [];
    
    if (tag) {
      countQuery += ` AND JSON_EXTRACT(metadata, '$.tags') LIKE ?`;
      countParams.push(`%"${tag}"%`);
    }
    
    if (author) {
      countQuery += ` AND JSON_EXTRACT(metadata, '$.author') = ?`;
      countParams.push(author);
    }
    
    const totalResult = await c.env.DB.prepare(countQuery).bind(...countParams).first();
    const total = totalResult?.total || 0;

    return c.json({
      articles: articles.results.map(article => ({
        ...article,
        metadata: JSON.parse(article.metadata)
      })),
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get articles error:', error);
    return c.json({ error: 'Failed to fetch articles' }, 500);
  }
});

// ç²å–å–®ç¯‡æ–‡ç«  - å¸¶ç·©å­˜
articlesRouter.get('/:slug', cacheMiddleware(3600), async (c) => {
  const slug = c.req.param('slug');
  
  try {
    const article = await c.env.DB.prepare(`
      SELECT * FROM articles WHERE slug = ?
    `).bind(slug).first();

    if (!article) {
      return c.json({ error: 'Article not found' }, 404);
    }

    // ç•°æ­¥å¢åŠ ç€è¦½æ¬¡æ•¸ï¼ˆä¸é˜»å¡éŸ¿æ‡‰ï¼‰
    c.executionCtx.waitUntil(
      c.env.DB.prepare(`
        UPDATE articles SET view_count = view_count + 1 WHERE slug = ?
      `).bind(slug).run()
    );

    return c.json({
      article: {
        ...article,
        metadata: JSON.parse(article.metadata)
      }
    });
  } catch (error) {
    console.error('Get article error:', error);
    return c.json({ error: 'Failed to fetch article' }, 500);
  }
});

// å‰µå»ºæ–‡ç«  - éœ€è¦èªè­‰
articlesRouter.post('/', authMiddleware, async (c) => {
  try {
    const body = await c.req.json();
    const validatedData = ArticleSchema.parse(body);
    
    const articleId = crypto.randomUUID();
    const now = new Date().toISOString();
    
    await c.env.DB.prepare(`
      INSERT INTO articles (id, slug, title, content, metadata, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      articleId,
      validatedData.slug,
      validatedData.title,
      validatedData.content,
      JSON.stringify(validatedData.metadata),
      now,
      now
    ).run();

    // æ¸…é™¤ç›¸é—œç·©å­˜
    await clearArticleCache(c, validatedData.slug);

    return c.json({ 
      id: articleId,
      slug: validatedData.slug,
      title: validatedData.title,
      createdAt: now 
    }, 201);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return c.json({ 
        error: 'Validation failed', 
        details: error.errors 
      }, 400);
    }
    console.error('Create article error:', error);
    return c.json({ error: 'Failed to create article' }, 500);
  }
});

// æ›´æ–°æ–‡ç« 
articlesRouter.put('/:slug', authMiddleware, async (c) => {
  const slug = c.req.param('slug');
  
  try {
    const body = await c.req.json();
    const validatedData = ArticleSchema.partial().parse(body);
    
    const updateFields: string[] = [];
    const params: any[] = [];
    
    if (validatedData.title) {
      updateFields.push('title = ?');
      params.push(validatedData.title);
    }
    
    if (validatedData.content) {
      updateFields.push('content = ?');
      params.push(validatedData.content);
    }
    
    if (validatedData.metadata) {
      updateFields.push('metadata = ?');
      params.push(JSON.stringify(validatedData.metadata));
    }
    
    updateFields.push('updated_at = ?');
    params.push(new Date().toISOString());
    params.push(slug);
    
    const result = await c.env.DB.prepare(`
      UPDATE articles SET ${updateFields.join(', ')} WHERE slug = ?
    `).bind(...params).run();

    if (result.changes === 0) {
      return c.json({ error: 'Article not found' }, 404);
    }

    // æ¸…é™¤ç·©å­˜
    await clearArticleCache(c, slug);

    return c.json({ success: true });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return c.json({ 
        error: 'Validation failed', 
        details: error.errors 
      }, 400);
    }
    console.error('Update article error:', error);
    return c.json({ error: 'Failed to update article' }, 500);
  }
});

// åˆªé™¤æ–‡ç« 
articlesRouter.delete('/:slug', authMiddleware, async (c) => {
  const slug = c.req.param('slug');
  
  try {
    const result = await c.env.DB.prepare(`
      DELETE FROM articles WHERE slug = ?
    `).bind(slug).run();

    if (result.changes === 0) {
      return c.json({ error: 'Article not found' }, 404);
    }

    // æ¸…é™¤ç·©å­˜
    await clearArticleCache(c, slug);

    return c.json({ success: true });
  } catch (error) {
    console.error('Delete article error:', error);
    return c.json({ error: 'Failed to delete article' }, 500);
  }
});

// ç·©å­˜æ¸…é™¤è¼”åŠ©å‡½æ•¸
async function clearArticleCache(c: any, slug: string) {
  if (c.env.CACHE) {
    const cacheKeys = [
      `cache:/api/articles/${slug}:`,
      'cache:/api/articles:',
    ];
    
    await Promise.all(
      cacheKeys.map(key => c.env.CACHE.delete(key))
    );
  }
}

export { articlesRouter };
```

**ç·©å­˜ä¸­é–“ä»¶ï¼š**
```typescript
// api/src/middleware/cache.ts
export function cacheMiddleware(ttl: number = 300) {
  return async (c: any, next: any) => {
    if (c.req.method !== 'GET') {
      await next();
      return;
    }

    const cacheKey = `cache:${c.req.path}:${c.req.query()}`;
    
    // å˜—è©¦å¾ KV ç²å–ç·©å­˜
    if (c.env.CACHE) {
      try {
        const cached = await c.env.CACHE.get(cacheKey);
        if (cached) {
          const data = JSON.parse(cached);
          return c.json(data, 200, {
            'X-Cache': 'HIT',
            'Cache-Control': `public, max-age=${ttl}`
          });
        }
      } catch (error) {
        console.warn('Cache read error:', error);
      }
    }

    await next();

    // ç·©å­˜æˆåŠŸéŸ¿æ‡‰
    if (c.res.status === 200) {
      try {
        const responseClone = c.res.clone();
        const data = await responseClone.json();
        
        if (c.env.CACHE) {
          await c.env.CACHE.put(cacheKey, JSON.stringify(data), {
            expirationTtl: ttl
          });
        }
        
        c.res.headers.set('X-Cache', 'MISS');
        c.res.headers.set('Cache-Control', `public, max-age=${ttl}`);
      } catch (error) {
        console.warn('Cache write error:', error);
      }
    }
  };
}
```

### ğŸ¯ å‰ç«¯æœå‹™æ›´æ–°

```typescript
// frontend/lib/api.ts
class BlogAPI {
  private baseURL: string;

  constructor() {
    this.baseURL = process.env.NODE_ENV === 'production' 
      ? 'https://api.blog.com'  // ç”Ÿç”¢ç’°å¢ƒ API åŸŸå
      : 'http://localhost:8787'; // æœ¬åœ°é–‹ç™¼
  }

  async getArticles(params?: {
    page?: number;
    limit?: number;
    tag?: string;
    author?: string;
    sort?: string;
  }) {
    const searchParams = new URLSearchParams();
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          searchParams.append(key, value.toString());
        }
      });
    }

    const response = await fetch(`${this.baseURL}/api/articles?${searchParams}`, {
      next: { revalidate: 300 }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to fetch articles: ${response.status}`);
    }
    
    return response.json();
  }

  async getArticle(slug: string) {
    const response = await fetch(`${this.baseURL}/api/articles/${slug}`, {
      next: { revalidate: 3600 }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error('Article not found');
      }
      throw new Error(`Failed to fetch article: ${response.status}`);
    }
    
    return response.json();
  }
}

export const blogAPI = new BlogAPI();
```

### ğŸš€ éƒ¨ç½²é…ç½®

**Cloudflare Workers é…ç½®ï¼š**
```toml
# api/wrangler.toml
name = "blog-api"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[env.production]
vars = { ENVIRONMENT = "production" }

# D1 æ•¸æ“šåº«
[[env.production.d1_databases]]
binding = "DB"
database_name = "blog-db"
database_id = "your-d1-database-id"

# R2 å­˜å„²
[[env.production.r2_buckets]]
binding = "BUCKET"
bucket_name = "blog-uploads"

# KV ç·©å­˜
[[env.production.kv_namespaces]]
binding = "CACHE"
id = "your-kv-namespace-id"

# è‡ªå®šç¾©åŸŸå
[env.production]
routes = [
  { pattern = "api.blog.com/*", zone_name = "blog.com" }
]
```

**Next.js é…ç½®ï¼š**
```typescript
// frontend/next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  env: {
    API_BASE_URL: process.env.NODE_ENV === 'production' 
      ? 'https://api.blog.com'
      : 'http://localhost:8787'
  },
  images: {
    domains: ['blog-uploads.r2.dev'],
  },
  // å…¶ä»–é…ç½®...
};

module.exports = nextConfig;
```

### âš¡ æ€§èƒ½å°æ¯”

<PerformanceComparison />

åŸºæ–¼å¯¦éš›æ¸¬è©¦çš„æ€§èƒ½æ•¸æ“šï¼š

| æŒ‡æ¨™ | éšæ®µ 1 (æ–‡ä»¶ç³»çµ±) | éšæ®µ 2 (API Routes) | éšæ®µ 3 (Hono API) |
|------|------------------|-------------------|------------------|
| **æ§‹å»ºæ™‚é–“** | 45 åˆ†é˜ (10K æ–‡ç« ) | 3 åˆ†é˜ | 2 åˆ†é˜ |
| **API éŸ¿æ‡‰æ™‚é–“** | N/A | 50-100ms | 5-15ms |
| **é¦–å±åŠ è¼‰** | 800ms | 600ms | 400ms |
| **ä½µç™¼èƒ½åŠ›** | ä½ | ä¸­ç­‰ | æ¥µé«˜ |
| **å…¨çƒå»¶é²** | å€åŸŸæ€§ | ä¸­ç­‰ | < 50ms |
| **å¯æ“´å±•æ€§** | å·® | ä¸­ç­‰ | å„ªç§€ |

### âœ… éšæ®µ 3 å„ªå‹¢
- **çœŸæ­£åˆ†é›¢**ï¼šå‰å¾Œç«¯å®Œå…¨ç¨ç«‹é–‹ç™¼ã€éƒ¨ç½²
- **æ¥µè‡´æ€§èƒ½**ï¼šHono + é‚Šç·£è¨ˆç®—ï¼Œå…¨çƒä½å»¶é²
- **ç„¡é™æ“´å±•**ï¼šå¯æ”¯æ´å¤šå€‹å‰ç«¯ã€ç§»å‹•æ‡‰ç”¨ã€ç¬¬ä¸‰æ–¹æ•´åˆ
- **æŠ€è¡“éˆæ´»**ï¼šå¯éš¨æ™‚æ›´æ›å‰ç«¯æ¡†æ¶æˆ–å¾Œç«¯æœå‹™
- **åœ˜éšŠå”ä½œ**ï¼šå‰å¾Œç«¯åœ˜éšŠå®Œå…¨è§£è€¦

### âŒ éšæ®µ 3 æŒ‘æˆ°
- **è¤‡é›œåº¦é«˜**ï¼šéœ€è¦ç®¡ç†å¤šå€‹æœå‹™
- **å­¸ç¿’æˆæœ¬**ï¼šéœ€è¦æŒæ¡æ›´å¤šæŠ€è¡“æ£§
- **éƒ¨ç½²è¤‡é›œ**ï¼šéœ€è¦å”èª¿å¤šå€‹æœå‹™çš„éƒ¨ç½²
- **é–‹ç™¼æˆæœ¬**ï¼šåˆæœŸæŠ•å…¥è¼ƒå¤§

---

## ğŸ¤” å¦‚ä½•é¸æ“‡åˆé©çš„éšæ®µï¼Ÿ

### éšæ®µé¸æ“‡æŒ‡å—

**é¸æ“‡éšæ®µ 1 çš„æ¢ä»¶ï¼š**
- âœ… æ–‡ç« æ•¸é‡ < 1,000 ç¯‡
- âœ… æ§‹å»ºæ™‚é–“ < 5 åˆ†é˜
- âœ… å–®äººæˆ–å°åœ˜éšŠé–‹ç™¼
- âœ… åªéœ€è¦ Web ç«¯è¨ªå•
- âœ… å¸Œæœ›å¿«é€Ÿå•Ÿå‹•é …ç›®

**å‡ç´šåˆ°éšæ®µ 2 çš„æ™‚æ©Ÿï¼š**
- ğŸ”„ æ–‡ç« æ•¸é‡ > 1,000 ç¯‡
- ğŸ”„ æ§‹å»ºæ™‚é–“éé•·å½±éŸ¿é–‹ç™¼æ•ˆç‡
- ğŸ”„ éœ€è¦å‹•æ…‹æ›´æ–°å…§å®¹
- ğŸ”„ é–‹å§‹è€ƒæ…®æä¾› API çµ¦å…¶ä»–æ‡‰ç”¨

**å‡ç´šåˆ°éšæ®µ 3 çš„æ™‚æ©Ÿï¼š**
- ğŸš€ éœ€è¦æ”¯æ´ç§»å‹•æ‡‰ç”¨æˆ–å¤šå€‹å‰ç«¯
- ğŸš€ API æ€§èƒ½æˆç‚ºç“¶é ¸
- ğŸš€ å‰å¾Œç«¯åœ˜éšŠå¸Œæœ›ç¨ç«‹é–‹ç™¼
- ğŸš€ éœ€è¦å¾®æœå‹™æ¶æ§‹çš„éˆæ´»æ€§

### ğŸ’° æˆæœ¬å°æ¯”

| é …ç›® | éšæ®µ 1 | éšæ®µ 2 | éšæ®µ 3 |
|------|--------|--------|--------|
| **é–‹ç™¼æˆæœ¬** | ä½ | ä¸­ | é«˜ |
| **ç¶­è­·æˆæœ¬** | ä½ | ä¸­ | ä¸­ |
| **é‹è¡Œæˆæœ¬** | ä½ | ä¸­ | ä½ï¼ˆé‚Šç·£è¨ˆç®—ï¼‰ |
| **å­¸ç¿’æˆæœ¬** | ä½ | ä¸­ | é«˜ |
| **æ™‚é–“æˆæœ¬** | 1-2 é€± | 2-4 é€± | 4-8 é€± |

## ğŸ›  å¯¦éš›é·ç§»æ­¥é©Ÿ

### å¾éšæ®µ 1 å‡ç´šåˆ°éšæ®µ 2

**1. è¨­ç½®æ•¸æ“šåº«**
```bash
# ä½¿ç”¨ PlanetScale æˆ–å…¶ä»– MySQL/PostgreSQL æä¾›å•†
npx prisma init
npx prisma generate
npx prisma db push
```

**2. å‰µå»ºé·ç§»è…³æœ¬**
```bash
# å°‡ç¾æœ‰ MDX æ–‡ä»¶é·ç§»åˆ°æ•¸æ“šåº«
npm run migrate:to-database
```

**3. æ·»åŠ  API Routes**
```bash
# å‰µå»º API è·¯ç”±æ–‡ä»¶
mkdir -p app/api/articles
touch app/api/articles/route.ts
touch app/api/articles/[slug]/route.ts
```

**4. æ›´æ–°å‰ç«¯é é¢**
```bash
# ä¿®æ”¹é é¢çµ„ä»¶ä½¿ç”¨ API è€Œä¸æ˜¯æ–‡ä»¶ç³»çµ±
# é…ç½® ISR å’Œç·©å­˜ç­–ç•¥
```

**5. æ¸¬è©¦å’Œé©—è­‰**
```bash
# æœ¬åœ°æ¸¬è©¦æ‰€æœ‰åŠŸèƒ½
npm run dev
# éƒ¨ç½²åˆ°æ¸¬è©¦ç’°å¢ƒ
npm run deploy:staging
```

### å¾éšæ®µ 2 å‡ç´šåˆ°éšæ®µ 3

**1. å‰µå»ºç¨ç«‹ API é …ç›®**
```bash
# å‰µå»ºæ–°çš„ API é …ç›®
mkdir blog-api
cd blog-api
npm init -y
npm install hono @hono/node-server
```

**2. é·ç§» API é‚è¼¯**
```bash
# å°‡ API Routes é‚è¼¯é·ç§»åˆ° Hono
# è¨­ç½®ä¸­é–“ä»¶å’Œè·¯ç”±
```

**3. é…ç½®éƒ¨ç½²**
```bash
# è¨­ç½® Cloudflare Workers éƒ¨ç½²
npm install -g wrangler
wrangler login
wrangler init
```

**4. æ›´æ–°å‰ç«¯é…ç½®**
```bash
# æ›´æ–° API åŸºç¤ URL
# è™•ç† CORS å’Œèªè­‰
```

**5. æ¼¸é€²å¼åˆ‡æ›**
```bash
# ä½¿ç”¨åŠŸèƒ½æ¨™èªŒé€æ­¥åˆ‡æ›åˆ°æ–° API
# ä¿æŒå…©å¥— API ä¸¦è¡Œé‹è¡Œä¸€æ®µæ™‚é–“
```

## ğŸ“Š å¯¦éš›æ¡ˆä¾‹åˆ†æ

### æ¡ˆä¾‹ï¼šTech Blog çš„æ¶æ§‹æ¼”é€²

**èƒŒæ™¯ï¼š**
- åˆå§‹ï¼š50 ç¯‡æŠ€è¡“æ–‡ç« 
- æˆé•·ï¼šæ¯æœˆæ–°å¢ 20-30 ç¯‡
- ç›®æ¨™ï¼šæ”¯æ´ 10,000+ ç¯‡æ–‡ç« 

**æ¼”é€²éç¨‹ï¼š**

**ç¬¬ä¸€å¹´ï¼ˆéšæ®µ 1ï¼‰ï¼š**
- æ–‡ç« æ•¸ï¼š50 â†’ 500 ç¯‡
- æ§‹å»ºæ™‚é–“ï¼š30 ç§’ â†’ 3 åˆ†é˜
- é–‹ç™¼æ•ˆç‡ï¼šé«˜
- ç”¨æˆ¶é«”é©—ï¼šå„ªç§€

**ç¬¬äºŒå¹´ï¼ˆå‡ç´šåˆ°éšæ®µ 2ï¼‰ï¼š**
- è§¸ç™¼é»ï¼šæ§‹å»ºæ™‚é–“è¶…é 5 åˆ†é˜
- å‡ç´šæ™‚é–“ï¼š2 é€±
- æ–‡ç« æ•¸ï¼š500 â†’ 2,000 ç¯‡
- æ§‹å»ºæ™‚é–“ï¼š3 åˆ†é˜ â†’ 2 åˆ†é˜
- æ–°å¢åŠŸèƒ½ï¼šæœç´¢ã€æ¨™ç±¤ç¯©é¸ã€ç€è¦½çµ±è¨ˆ

**ç¬¬ä¸‰å¹´ï¼ˆå‡ç´šåˆ°éšæ®µ 3ï¼‰ï¼š**
- è§¸ç™¼é»ï¼šéœ€è¦æ”¯æ´ç§»å‹•æ‡‰ç”¨
- å‡ç´šæ™‚é–“ï¼š1 å€‹æœˆ
- æ–‡ç« æ•¸ï¼š2,000 â†’ 8,000 ç¯‡
- API éŸ¿æ‡‰ï¼š50ms â†’ 15ms
- æ–°å¢åŠŸèƒ½ï¼šç§»å‹• Appã€ç¬¬ä¸‰æ–¹æ•´åˆã€å¤šä½œè€…ç³»çµ±

**æœ€çµ‚çµæœï¼š**
- ğŸ“ˆ ç”¨æˆ¶å¢é•·ï¼š10å€
- âš¡ æ€§èƒ½æå‡ï¼š5å€
- ğŸ”§ é–‹ç™¼æ•ˆç‡ï¼šä¿æŒé«˜æ•ˆ
- ğŸ’° é‹è¡Œæˆæœ¬ï¼šé™ä½ 30%

## ç¸½çµ

MDX éƒ¨è½æ ¼çš„å‰å¾Œç«¯åˆ†é›¢ä¸æ˜¯ä¸€è¹´è€Œå°±çš„ï¼Œè€Œæ˜¯ä¸€å€‹æ¼¸é€²å¼çš„æ¼”é€²éç¨‹ã€‚é€šéä¸‰å€‹éšæ®µçš„å‡ç´šè·¯å¾‘ï¼Œä½ å¯ä»¥ï¼š

1. **å¾ç°¡å–®é–‹å§‹**ï¼šéšæ®µ 1 è®“ä½ å¿«é€Ÿå•Ÿå‹•é …ç›®
2. **é©æ™‚å‡ç´š**ï¼šéšæ®µ 2 è§£æ±ºæ€§èƒ½ç“¶é ¸ï¼Œä¿æŒé–‹ç™¼ç°¡å–®
3. **è¿½æ±‚æ¥µè‡´**ï¼šéšæ®µ 3 å¯¦ç¾çœŸæ­£çš„å‰å¾Œç«¯åˆ†é›¢ï¼Œæ”¯æ´å¤§è¦æ¨¡æ‡‰ç”¨

**é—œéµåŸå‰‡ï¼š**
- ğŸ¯ **æŒ‰éœ€å‡ç´š**ï¼šä¸è¦éåº¦è¨­è¨ˆï¼Œæ ¹æ“šå¯¦éš›éœ€æ±‚é¸æ“‡éšæ®µ
- ğŸ“Š **æ•¸æ“šé©…å‹•**ï¼šç”¨å…·é«”æŒ‡æ¨™æ±ºå®šå‡ç´šæ™‚æ©Ÿ
- ğŸ”„ **æ¼¸é€²æ¼”é€²**ï¼šå°æ­¥å¿«è·‘ï¼Œé™ä½é‡æ§‹é¢¨éšª
- ğŸ›  **å·¥å…·é¸æ“‡**ï¼šé¸æ“‡é©åˆåœ˜éšŠæŠ€è¡“æ£§çš„å·¥å…·

è¨˜ä½ï¼Œ**æœ€å¥½çš„æ¶æ§‹æ˜¯èƒ½å¤ æ»¿è¶³ç•¶å‰éœ€æ±‚ä¸¦ç‚ºæœªä¾†ç•™æœ‰æ¼”é€²ç©ºé–“çš„æ¶æ§‹**ã€‚å¾ Next.js å–®é«”æ‡‰ç”¨é–‹å§‹ï¼Œç•¶çœŸæ­£éœ€è¦æ™‚å†å‡ç´šåˆ°å‰å¾Œç«¯åˆ†é›¢ï¼Œé€™æ˜¯ä¸€æ¢é¢¨éšªæœ€å°ã€æ”¶ç›Šæœ€å¤§çš„æŠ€è¡“æ¼”é€²ä¹‹è·¯ã€‚

é–‹å§‹ä½ çš„ MDX éƒ¨è½æ ¼æ¶æ§‹æ¼”é€²ä¹‹æ—…å§ï¼ğŸš€